/*
 * generated by Xtext 2.17.0
 */
package dume.compiler.services;

import com.google.inject.Inject;
import com.google.inject.Singleton;
import java.util.List;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Alternatives;
import org.eclipse.xtext.Assignment;
import org.eclipse.xtext.Grammar;
import org.eclipse.xtext.GrammarUtil;
import org.eclipse.xtext.Group;
import org.eclipse.xtext.Keyword;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.RuleCall;
import org.eclipse.xtext.TerminalRule;
import org.eclipse.xtext.common.services.TerminalsGrammarAccess;
import org.eclipse.xtext.service.AbstractElementFinder.AbstractGrammarElementFinder;
import org.eclipse.xtext.service.GrammarProvider;

@Singleton
public class DumeGrammarAccess extends AbstractGrammarElementFinder {
	
	public class ScriptsElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "dume.compiler.Dume.Scripts");
		private final Assignment cScriptAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cScriptScriptParserRuleCall_0 = (RuleCall)cScriptAssignment.eContents().get(0);
		
		//Scripts:
		//	script+=Script*;
		@Override public ParserRule getRule() { return rule; }
		
		//script+=Script*
		public Assignment getScriptAssignment() { return cScriptAssignment; }
		
		//Script
		public RuleCall getScriptScriptParserRuleCall_0() { return cScriptScriptParserRuleCall_0; }
	}
	public class ScriptElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "dume.compiler.Dume.Script");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cScriptKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Keyword cLeftCurlyBracketKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cInstructionsAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cInstructionsInstructionParserRuleCall_3_0 = (RuleCall)cInstructionsAssignment_3.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		//Script:
		//	'Script' name=ID '{' instructions+=Instruction* '}';
		@Override public ParserRule getRule() { return rule; }
		
		//'Script' name=ID '{' instructions+=Instruction* '}'
		public Group getGroup() { return cGroup; }
		
		//'Script'
		public Keyword getScriptKeyword_0() { return cScriptKeyword_0; }
		
		//name=ID
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_1_0() { return cNameIDTerminalRuleCall_1_0; }
		
		//'{'
		public Keyword getLeftCurlyBracketKeyword_2() { return cLeftCurlyBracketKeyword_2; }
		
		//instructions+=Instruction*
		public Assignment getInstructionsAssignment_3() { return cInstructionsAssignment_3; }
		
		//Instruction
		public RuleCall getInstructionsInstructionParserRuleCall_3_0() { return cInstructionsInstructionParserRuleCall_3_0; }
		
		//'}'
		public Keyword getRightCurlyBracketKeyword_4() { return cRightCurlyBracketKeyword_4; }
	}
	public class InstructionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "dume.compiler.Dume.Instruction");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cDrawingParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cClearParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cGoParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cLoopParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		
		//Instruction:
		//	Drawing
		//	| Clear
		//	| Go
		//	| Loop;
		@Override public ParserRule getRule() { return rule; }
		
		//Drawing | Clear | Go | Loop
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//Drawing
		public RuleCall getDrawingParserRuleCall_0() { return cDrawingParserRuleCall_0; }
		
		//Clear
		public RuleCall getClearParserRuleCall_1() { return cClearParserRuleCall_1; }
		
		//Go
		public RuleCall getGoParserRuleCall_2() { return cGoParserRuleCall_2; }
		
		//Loop
		public RuleCall getLoopParserRuleCall_3() { return cLoopParserRuleCall_3; }
	}
	public class MapElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "dume.compiler.Dume.Map");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cAKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cBKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		private final Keyword cCKeyword_2 = (Keyword)cAlternatives.eContents().get(2);
		private final Keyword cDKeyword_3 = (Keyword)cAlternatives.eContents().get(3);
		private final Keyword cEKeyword_4 = (Keyword)cAlternatives.eContents().get(4);
		private final Keyword cFKeyword_5 = (Keyword)cAlternatives.eContents().get(5);
		
		//Map:
		//	'A' | 'B' | 'C' | 'D' | 'E' | 'F';
		@Override public ParserRule getRule() { return rule; }
		
		//'A' | 'B' | 'C' | 'D' | 'E' | 'F'
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//'A'
		public Keyword getAKeyword_0() { return cAKeyword_0; }
		
		//'B'
		public Keyword getBKeyword_1() { return cBKeyword_1; }
		
		//'C'
		public Keyword getCKeyword_2() { return cCKeyword_2; }
		
		//'D'
		public Keyword getDKeyword_3() { return cDKeyword_3; }
		
		//'E'
		public Keyword getEKeyword_4() { return cEKeyword_4; }
		
		//'F'
		public Keyword getFKeyword_5() { return cFKeyword_5; }
	}
	public class Point3DElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "dume.compiler.Dume.Point3D");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cXAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cXINTTerminalRuleCall_1_0 = (RuleCall)cXAssignment_1.eContents().get(0);
		private final Assignment cYAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cYINTTerminalRuleCall_2_0 = (RuleCall)cYAssignment_2.eContents().get(0);
		private final Assignment cZAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cZINTTerminalRuleCall_3_0 = (RuleCall)cZAssignment_3.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		//Point3D:
		//	'(' x=INT y=INT z=INT ')';
		@Override public ParserRule getRule() { return rule; }
		
		//'(' x=INT y=INT z=INT ')'
		public Group getGroup() { return cGroup; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_0() { return cLeftParenthesisKeyword_0; }
		
		//x=INT
		public Assignment getXAssignment_1() { return cXAssignment_1; }
		
		//INT
		public RuleCall getXINTTerminalRuleCall_1_0() { return cXINTTerminalRuleCall_1_0; }
		
		//y=INT
		public Assignment getYAssignment_2() { return cYAssignment_2; }
		
		//INT
		public RuleCall getYINTTerminalRuleCall_2_0() { return cYINTTerminalRuleCall_2_0; }
		
		//z=INT
		public Assignment getZAssignment_3() { return cZAssignment_3; }
		
		//INT
		public RuleCall getZINTTerminalRuleCall_3_0() { return cZINTTerminalRuleCall_3_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_4() { return cRightParenthesisKeyword_4; }
	}
	public class Point2DElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "dume.compiler.Dume.Point2D");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cIAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cIINTTerminalRuleCall_1_0 = (RuleCall)cIAssignment_1.eContents().get(0);
		private final Assignment cJAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cJINTTerminalRuleCall_2_0 = (RuleCall)cJAssignment_2.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//Point2D:
		//	'(' i=INT j=INT ')';
		@Override public ParserRule getRule() { return rule; }
		
		//'(' i=INT j=INT ')'
		public Group getGroup() { return cGroup; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_0() { return cLeftParenthesisKeyword_0; }
		
		//i=INT
		public Assignment getIAssignment_1() { return cIAssignment_1; }
		
		//INT
		public RuleCall getIINTTerminalRuleCall_1_0() { return cIINTTerminalRuleCall_1_0; }
		
		//j=INT
		public Assignment getJAssignment_2() { return cJAssignment_2; }
		
		//INT
		public RuleCall getJINTTerminalRuleCall_2_0() { return cJINTTerminalRuleCall_2_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_3() { return cRightParenthesisKeyword_3; }
	}
	public class PointElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "dume.compiler.Dume.Point");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cPoint3DParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final RuleCall cPoint2DParserRuleCall_1_0 = (RuleCall)cGroup_1.eContents().get(0);
		private final Keyword cOnKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cMapAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cMapMapParserRuleCall_1_2_0 = (RuleCall)cMapAssignment_1_2.eContents().get(0);
		
		//Point:
		//	Point3D
		//	| Point2D 'on' map=Map;
		@Override public ParserRule getRule() { return rule; }
		
		//Point3D | Point2D 'on' map=Map
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//Point3D
		public RuleCall getPoint3DParserRuleCall_0() { return cPoint3DParserRuleCall_0; }
		
		//Point2D 'on' map=Map
		public Group getGroup_1() { return cGroup_1; }
		
		//Point2D
		public RuleCall getPoint2DParserRuleCall_1_0() { return cPoint2DParserRuleCall_1_0; }
		
		//'on'
		public Keyword getOnKeyword_1_1() { return cOnKeyword_1_1; }
		
		//map=Map
		public Assignment getMapAssignment_1_2() { return cMapAssignment_1_2; }
		
		//Map
		public RuleCall getMapMapParserRuleCall_1_2_0() { return cMapMapParserRuleCall_1_2_0; }
	}
	public class ShapeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "dume.compiler.Dume.Shape");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cShape2DParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cShape3DParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cCircleParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		
		//Shape:
		//	Shape2D
		//	| Shape3D
		//	| Circle;
		@Override public ParserRule getRule() { return rule; }
		
		//Shape2D | Shape3D | Circle
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//Shape2D
		public RuleCall getShape2DParserRuleCall_0() { return cShape2DParserRuleCall_0; }
		
		//Shape3D
		public RuleCall getShape3DParserRuleCall_1() { return cShape3DParserRuleCall_1; }
		
		//Circle
		public RuleCall getCircleParserRuleCall_2() { return cCircleParserRuleCall_2; }
	}
	public class Shape3DElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "dume.compiler.Dume.Shape3D");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cShape3DAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cShapeKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Keyword cLeftCurlyBracketKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cPointsAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cPointsPoint3DParserRuleCall_3_0 = (RuleCall)cPointsAssignment_3.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		//Shape3D:
		//	{Shape3D} 'shape' '{' points+=Point3D* '}';
		@Override public ParserRule getRule() { return rule; }
		
		//{Shape3D} 'shape' '{' points+=Point3D* '}'
		public Group getGroup() { return cGroup; }
		
		//{Shape3D}
		public Action getShape3DAction_0() { return cShape3DAction_0; }
		
		//'shape'
		public Keyword getShapeKeyword_1() { return cShapeKeyword_1; }
		
		//'{'
		public Keyword getLeftCurlyBracketKeyword_2() { return cLeftCurlyBracketKeyword_2; }
		
		//points+=Point3D*
		public Assignment getPointsAssignment_3() { return cPointsAssignment_3; }
		
		//Point3D
		public RuleCall getPointsPoint3DParserRuleCall_3_0() { return cPointsPoint3DParserRuleCall_3_0; }
		
		//'}'
		public Keyword getRightCurlyBracketKeyword_4() { return cRightCurlyBracketKeyword_4; }
	}
	public class Shape2DElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "dume.compiler.Dume.Shape2D");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cShape2DAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cShapeKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Keyword cOnKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cMapAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cMapMapParserRuleCall_3_0 = (RuleCall)cMapAssignment_3.eContents().get(0);
		private final Keyword cLeftCurlyBracketKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Assignment cPointsAssignment_5 = (Assignment)cGroup.eContents().get(5);
		private final RuleCall cPointsPoint2DParserRuleCall_5_0 = (RuleCall)cPointsAssignment_5.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_6 = (Keyword)cGroup.eContents().get(6);
		
		//Shape2D:
		//	{Shape2D} 'shape' 'on' map=Map '{' points+=Point2D* '}';
		@Override public ParserRule getRule() { return rule; }
		
		//{Shape2D} 'shape' 'on' map=Map '{' points+=Point2D* '}'
		public Group getGroup() { return cGroup; }
		
		//{Shape2D}
		public Action getShape2DAction_0() { return cShape2DAction_0; }
		
		//'shape'
		public Keyword getShapeKeyword_1() { return cShapeKeyword_1; }
		
		//'on'
		public Keyword getOnKeyword_2() { return cOnKeyword_2; }
		
		//map=Map
		public Assignment getMapAssignment_3() { return cMapAssignment_3; }
		
		//Map
		public RuleCall getMapMapParserRuleCall_3_0() { return cMapMapParserRuleCall_3_0; }
		
		//'{'
		public Keyword getLeftCurlyBracketKeyword_4() { return cLeftCurlyBracketKeyword_4; }
		
		//points+=Point2D*
		public Assignment getPointsAssignment_5() { return cPointsAssignment_5; }
		
		//Point2D
		public RuleCall getPointsPoint2DParserRuleCall_5_0() { return cPointsPoint2DParserRuleCall_5_0; }
		
		//'}'
		public Keyword getRightCurlyBracketKeyword_6() { return cRightCurlyBracketKeyword_6; }
	}
	public class DrawingElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "dume.compiler.Dume.Drawing");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cDrawingAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cDrawingKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Keyword cLeftCurlyBracketKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cShapesAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cShapesShapeParserRuleCall_3_0 = (RuleCall)cShapesAssignment_3.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		//Drawing:
		//	{Drawing} 'drawing' '{' shapes+=Shape* '}';
		@Override public ParserRule getRule() { return rule; }
		
		//{Drawing} 'drawing' '{' shapes+=Shape* '}'
		public Group getGroup() { return cGroup; }
		
		//{Drawing}
		public Action getDrawingAction_0() { return cDrawingAction_0; }
		
		//'drawing'
		public Keyword getDrawingKeyword_1() { return cDrawingKeyword_1; }
		
		//'{'
		public Keyword getLeftCurlyBracketKeyword_2() { return cLeftCurlyBracketKeyword_2; }
		
		//shapes+=Shape*
		public Assignment getShapesAssignment_3() { return cShapesAssignment_3; }
		
		//Shape
		public RuleCall getShapesShapeParserRuleCall_3_0() { return cShapesShapeParserRuleCall_3_0; }
		
		//'}'
		public Keyword getRightCurlyBracketKeyword_4() { return cRightCurlyBracketKeyword_4; }
	}
	public class ClearElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "dume.compiler.Dume.Clear");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cClearAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cClearKeyword_1 = (Keyword)cGroup.eContents().get(1);
		
		//Clear:
		//	{Clear} 'clear';
		@Override public ParserRule getRule() { return rule; }
		
		//{Clear} 'clear'
		public Group getGroup() { return cGroup; }
		
		//{Clear}
		public Action getClearAction_0() { return cClearAction_0; }
		
		//'clear'
		public Keyword getClearKeyword_1() { return cClearKeyword_1; }
	}
	public class GoElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "dume.compiler.Dume.Go");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cGoKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cPointAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cPointPointParserRuleCall_1_0 = (RuleCall)cPointAssignment_1.eContents().get(0);
		
		//Go:
		//	'go' point=Point;
		@Override public ParserRule getRule() { return rule; }
		
		//'go' point=Point
		public Group getGroup() { return cGroup; }
		
		//'go'
		public Keyword getGoKeyword_0() { return cGoKeyword_0; }
		
		//point=Point
		public Assignment getPointAssignment_1() { return cPointAssignment_1; }
		
		//Point
		public RuleCall getPointPointParserRuleCall_1_0() { return cPointPointParserRuleCall_1_0; }
	}
	public class CircleElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "dume.compiler.Dume.Circle");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cCircleKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cCenterKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cPointAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cPointPoint2DParserRuleCall_2_0 = (RuleCall)cPointAssignment_2.eContents().get(0);
		private final Keyword cRadiusKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cRadiusAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cRadiusINTTerminalRuleCall_4_0 = (RuleCall)cRadiusAssignment_4.eContents().get(0);
		private final Keyword cOnKeyword_5 = (Keyword)cGroup.eContents().get(5);
		private final Assignment cMapAssignment_6 = (Assignment)cGroup.eContents().get(6);
		private final RuleCall cMapMapParserRuleCall_6_0 = (RuleCall)cMapAssignment_6.eContents().get(0);
		
		//Circle:
		//	'circle' 'center' point=Point2D 'radius' radius=INT 'on' map=Map;
		@Override public ParserRule getRule() { return rule; }
		
		//'circle' 'center' point=Point2D 'radius' radius=INT 'on' map=Map
		public Group getGroup() { return cGroup; }
		
		//'circle'
		public Keyword getCircleKeyword_0() { return cCircleKeyword_0; }
		
		//'center'
		public Keyword getCenterKeyword_1() { return cCenterKeyword_1; }
		
		//point=Point2D
		public Assignment getPointAssignment_2() { return cPointAssignment_2; }
		
		//Point2D
		public RuleCall getPointPoint2DParserRuleCall_2_0() { return cPointPoint2DParserRuleCall_2_0; }
		
		//'radius'
		public Keyword getRadiusKeyword_3() { return cRadiusKeyword_3; }
		
		//radius=INT
		public Assignment getRadiusAssignment_4() { return cRadiusAssignment_4; }
		
		//INT
		public RuleCall getRadiusINTTerminalRuleCall_4_0() { return cRadiusINTTerminalRuleCall_4_0; }
		
		//'on'
		public Keyword getOnKeyword_5() { return cOnKeyword_5; }
		
		//map=Map
		public Assignment getMapAssignment_6() { return cMapAssignment_6; }
		
		//Map
		public RuleCall getMapMapParserRuleCall_6_0() { return cMapMapParserRuleCall_6_0; }
	}
	public class LoopElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "dume.compiler.Dume.Loop");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cLoopKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNINTTerminalRuleCall_1_0 = (RuleCall)cNAssignment_1.eContents().get(0);
		private final Keyword cLeftCurlyBracketKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cInstructionsAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cInstructionsInstructionParserRuleCall_3_0 = (RuleCall)cInstructionsAssignment_3.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		//Loop:
		//	'loop' n=INT '{' instructions+=Instruction* '}';
		@Override public ParserRule getRule() { return rule; }
		
		//'loop' n=INT '{' instructions+=Instruction* '}'
		public Group getGroup() { return cGroup; }
		
		//'loop'
		public Keyword getLoopKeyword_0() { return cLoopKeyword_0; }
		
		//n=INT
		public Assignment getNAssignment_1() { return cNAssignment_1; }
		
		//INT
		public RuleCall getNINTTerminalRuleCall_1_0() { return cNINTTerminalRuleCall_1_0; }
		
		//'{'
		public Keyword getLeftCurlyBracketKeyword_2() { return cLeftCurlyBracketKeyword_2; }
		
		//instructions+=Instruction*
		public Assignment getInstructionsAssignment_3() { return cInstructionsAssignment_3; }
		
		//Instruction
		public RuleCall getInstructionsInstructionParserRuleCall_3_0() { return cInstructionsInstructionParserRuleCall_3_0; }
		
		//'}'
		public Keyword getRightCurlyBracketKeyword_4() { return cRightCurlyBracketKeyword_4; }
	}
	
	
	private final ScriptsElements pScripts;
	private final ScriptElements pScript;
	private final InstructionElements pInstruction;
	private final MapElements pMap;
	private final Point3DElements pPoint3D;
	private final Point2DElements pPoint2D;
	private final PointElements pPoint;
	private final ShapeElements pShape;
	private final Shape3DElements pShape3D;
	private final Shape2DElements pShape2D;
	private final DrawingElements pDrawing;
	private final ClearElements pClear;
	private final GoElements pGo;
	private final CircleElements pCircle;
	private final LoopElements pLoop;
	
	private final Grammar grammar;
	
	private final TerminalsGrammarAccess gaTerminals;

	@Inject
	public DumeGrammarAccess(GrammarProvider grammarProvider,
			TerminalsGrammarAccess gaTerminals) {
		this.grammar = internalFindGrammar(grammarProvider);
		this.gaTerminals = gaTerminals;
		this.pScripts = new ScriptsElements();
		this.pScript = new ScriptElements();
		this.pInstruction = new InstructionElements();
		this.pMap = new MapElements();
		this.pPoint3D = new Point3DElements();
		this.pPoint2D = new Point2DElements();
		this.pPoint = new PointElements();
		this.pShape = new ShapeElements();
		this.pShape3D = new Shape3DElements();
		this.pShape2D = new Shape2DElements();
		this.pDrawing = new DrawingElements();
		this.pClear = new ClearElements();
		this.pGo = new GoElements();
		this.pCircle = new CircleElements();
		this.pLoop = new LoopElements();
	}
	
	protected Grammar internalFindGrammar(GrammarProvider grammarProvider) {
		Grammar grammar = grammarProvider.getGrammar(this);
		while (grammar != null) {
			if ("dume.compiler.Dume".equals(grammar.getName())) {
				return grammar;
			}
			List<Grammar> grammars = grammar.getUsedGrammars();
			if (!grammars.isEmpty()) {
				grammar = grammars.iterator().next();
			} else {
				return null;
			}
		}
		return grammar;
	}
	
	@Override
	public Grammar getGrammar() {
		return grammar;
	}
	
	
	public TerminalsGrammarAccess getTerminalsGrammarAccess() {
		return gaTerminals;
	}

	
	//Scripts:
	//	script+=Script*;
	public ScriptsElements getScriptsAccess() {
		return pScripts;
	}
	
	public ParserRule getScriptsRule() {
		return getScriptsAccess().getRule();
	}
	
	//Script:
	//	'Script' name=ID '{' instructions+=Instruction* '}';
	public ScriptElements getScriptAccess() {
		return pScript;
	}
	
	public ParserRule getScriptRule() {
		return getScriptAccess().getRule();
	}
	
	//Instruction:
	//	Drawing
	//	| Clear
	//	| Go
	//	| Loop;
	public InstructionElements getInstructionAccess() {
		return pInstruction;
	}
	
	public ParserRule getInstructionRule() {
		return getInstructionAccess().getRule();
	}
	
	//Map:
	//	'A' | 'B' | 'C' | 'D' | 'E' | 'F';
	public MapElements getMapAccess() {
		return pMap;
	}
	
	public ParserRule getMapRule() {
		return getMapAccess().getRule();
	}
	
	//Point3D:
	//	'(' x=INT y=INT z=INT ')';
	public Point3DElements getPoint3DAccess() {
		return pPoint3D;
	}
	
	public ParserRule getPoint3DRule() {
		return getPoint3DAccess().getRule();
	}
	
	//Point2D:
	//	'(' i=INT j=INT ')';
	public Point2DElements getPoint2DAccess() {
		return pPoint2D;
	}
	
	public ParserRule getPoint2DRule() {
		return getPoint2DAccess().getRule();
	}
	
	//Point:
	//	Point3D
	//	| Point2D 'on' map=Map;
	public PointElements getPointAccess() {
		return pPoint;
	}
	
	public ParserRule getPointRule() {
		return getPointAccess().getRule();
	}
	
	//Shape:
	//	Shape2D
	//	| Shape3D
	//	| Circle;
	public ShapeElements getShapeAccess() {
		return pShape;
	}
	
	public ParserRule getShapeRule() {
		return getShapeAccess().getRule();
	}
	
	//Shape3D:
	//	{Shape3D} 'shape' '{' points+=Point3D* '}';
	public Shape3DElements getShape3DAccess() {
		return pShape3D;
	}
	
	public ParserRule getShape3DRule() {
		return getShape3DAccess().getRule();
	}
	
	//Shape2D:
	//	{Shape2D} 'shape' 'on' map=Map '{' points+=Point2D* '}';
	public Shape2DElements getShape2DAccess() {
		return pShape2D;
	}
	
	public ParserRule getShape2DRule() {
		return getShape2DAccess().getRule();
	}
	
	//Drawing:
	//	{Drawing} 'drawing' '{' shapes+=Shape* '}';
	public DrawingElements getDrawingAccess() {
		return pDrawing;
	}
	
	public ParserRule getDrawingRule() {
		return getDrawingAccess().getRule();
	}
	
	//Clear:
	//	{Clear} 'clear';
	public ClearElements getClearAccess() {
		return pClear;
	}
	
	public ParserRule getClearRule() {
		return getClearAccess().getRule();
	}
	
	//Go:
	//	'go' point=Point;
	public GoElements getGoAccess() {
		return pGo;
	}
	
	public ParserRule getGoRule() {
		return getGoAccess().getRule();
	}
	
	//Circle:
	//	'circle' 'center' point=Point2D 'radius' radius=INT 'on' map=Map;
	public CircleElements getCircleAccess() {
		return pCircle;
	}
	
	public ParserRule getCircleRule() {
		return getCircleAccess().getRule();
	}
	
	//Loop:
	//	'loop' n=INT '{' instructions+=Instruction* '}';
	public LoopElements getLoopAccess() {
		return pLoop;
	}
	
	public ParserRule getLoopRule() {
		return getLoopAccess().getRule();
	}
	
	//terminal ID:
	//	'^'? ('a'..'z' | 'A'..'Z' | '_') ('a'..'z' | 'A'..'Z' | '_' | '0'..'9')*;
	public TerminalRule getIDRule() {
		return gaTerminals.getIDRule();
	}
	
	//terminal INT returns ecore::EInt:
	//	'0'..'9'+;
	public TerminalRule getINTRule() {
		return gaTerminals.getINTRule();
	}
	
	//terminal STRING:
	//	'"' ('\\' . | !('\\' | '"'))* '"' |
	//	"'" ('\\' . | !('\\' | "'"))* "'";
	public TerminalRule getSTRINGRule() {
		return gaTerminals.getSTRINGRule();
	}
	
	//terminal ML_COMMENT:
	//	'/*'->'*/';
	public TerminalRule getML_COMMENTRule() {
		return gaTerminals.getML_COMMENTRule();
	}
	
	//terminal SL_COMMENT:
	//	'//' !('\n' | '\r')* ('\r'? '\n')?;
	public TerminalRule getSL_COMMENTRule() {
		return gaTerminals.getSL_COMMENTRule();
	}
	
	//terminal WS:
	//	' ' | '\t' | '\r' | '\n'+;
	public TerminalRule getWSRule() {
		return gaTerminals.getWSRule();
	}
	
	//terminal ANY_OTHER:
	//	.;
	public TerminalRule getANY_OTHERRule() {
		return gaTerminals.getANY_OTHERRule();
	}
}
