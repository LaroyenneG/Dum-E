/*
 * generated by Xtext 2.17.0
 */
package dume.compiler.serializer;

import com.google.inject.Inject;
import dume.compiler.dume.Circle;
import dume.compiler.dume.Clear;
import dume.compiler.dume.Drawing;
import dume.compiler.dume.DumePackage;
import dume.compiler.dume.Go;
import dume.compiler.dume.Loop;
import dume.compiler.dume.Point2D;
import dume.compiler.dume.Point3D;
import dume.compiler.dume.Script;
import dume.compiler.dume.Scripts;
import dume.compiler.dume.Shape2D;
import dume.compiler.dume.Shape3D;
import dume.compiler.services.DumeGrammarAccess;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class DumeSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private DumeGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == DumePackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case DumePackage.CIRCLE:
				sequence_Circle(context, (Circle) semanticObject); 
				return; 
			case DumePackage.CLEAR:
				sequence_Clear(context, (Clear) semanticObject); 
				return; 
			case DumePackage.DRAWING:
				sequence_Drawing(context, (Drawing) semanticObject); 
				return; 
			case DumePackage.GO:
				sequence_Go(context, (Go) semanticObject); 
				return; 
			case DumePackage.LOOP:
				sequence_Loop(context, (Loop) semanticObject); 
				return; 
			case DumePackage.POINT2_D:
				if (rule == grammarAccess.getPoint2DRule()) {
					sequence_Point2D(context, (Point2D) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getPointRule()) {
					sequence_Point_Point2D(context, (Point2D) semanticObject); 
					return; 
				}
				else break;
			case DumePackage.POINT3_D:
				sequence_Point3D(context, (Point3D) semanticObject); 
				return; 
			case DumePackage.SCRIPT:
				sequence_Script(context, (Script) semanticObject); 
				return; 
			case DumePackage.SCRIPTS:
				sequence_Scripts(context, (Scripts) semanticObject); 
				return; 
			case DumePackage.SHAPE2_D:
				sequence_Shape2D(context, (Shape2D) semanticObject); 
				return; 
			case DumePackage.SHAPE3_D:
				sequence_Shape3D(context, (Shape3D) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     Shape returns Circle
	 *     Circle returns Circle
	 *
	 * Constraint:
	 *     (point=Point2D radius=INT map=Map)
	 */
	protected void sequence_Circle(ISerializationContext context, Circle semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DumePackage.Literals.CIRCLE__POINT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DumePackage.Literals.CIRCLE__POINT));
			if (transientValues.isValueTransient(semanticObject, DumePackage.Literals.CIRCLE__RADIUS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DumePackage.Literals.CIRCLE__RADIUS));
			if (transientValues.isValueTransient(semanticObject, DumePackage.Literals.CIRCLE__MAP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DumePackage.Literals.CIRCLE__MAP));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCircleAccess().getPointPoint2DParserRuleCall_2_0(), semanticObject.getPoint());
		feeder.accept(grammarAccess.getCircleAccess().getRadiusINTTerminalRuleCall_4_0(), semanticObject.getRadius());
		feeder.accept(grammarAccess.getCircleAccess().getMapMapParserRuleCall_6_0(), semanticObject.getMap());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Instruction returns Clear
	 *     Clear returns Clear
	 *
	 * Constraint:
	 *     {Clear}
	 */
	protected void sequence_Clear(ISerializationContext context, Clear semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Instruction returns Drawing
	 *     Drawing returns Drawing
	 *
	 * Constraint:
	 *     shapes+=Shape*
	 */
	protected void sequence_Drawing(ISerializationContext context, Drawing semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Instruction returns Go
	 *     Go returns Go
	 *
	 * Constraint:
	 *     point=Point
	 */
	protected void sequence_Go(ISerializationContext context, Go semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DumePackage.Literals.GO__POINT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DumePackage.Literals.GO__POINT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getGoAccess().getPointPointParserRuleCall_1_0(), semanticObject.getPoint());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Instruction returns Loop
	 *     Loop returns Loop
	 *
	 * Constraint:
	 *     (n=INT instructions+=Instruction*)
	 */
	protected void sequence_Loop(ISerializationContext context, Loop semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Point2D returns Point2D
	 *
	 * Constraint:
	 *     (i=INT j=INT)
	 */
	protected void sequence_Point2D(ISerializationContext context, Point2D semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DumePackage.Literals.POINT2_D__I) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DumePackage.Literals.POINT2_D__I));
			if (transientValues.isValueTransient(semanticObject, DumePackage.Literals.POINT2_D__J) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DumePackage.Literals.POINT2_D__J));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPoint2DAccess().getIINTTerminalRuleCall_1_0(), semanticObject.getI());
		feeder.accept(grammarAccess.getPoint2DAccess().getJINTTerminalRuleCall_2_0(), semanticObject.getJ());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Point3D returns Point3D
	 *     Point returns Point3D
	 *
	 * Constraint:
	 *     (x=INT y=INT z=INT)
	 */
	protected void sequence_Point3D(ISerializationContext context, Point3D semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DumePackage.Literals.POINT3_D__X) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DumePackage.Literals.POINT3_D__X));
			if (transientValues.isValueTransient(semanticObject, DumePackage.Literals.POINT3_D__Y) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DumePackage.Literals.POINT3_D__Y));
			if (transientValues.isValueTransient(semanticObject, DumePackage.Literals.POINT3_D__Z) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DumePackage.Literals.POINT3_D__Z));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPoint3DAccess().getXINTTerminalRuleCall_1_0(), semanticObject.getX());
		feeder.accept(grammarAccess.getPoint3DAccess().getYINTTerminalRuleCall_2_0(), semanticObject.getY());
		feeder.accept(grammarAccess.getPoint3DAccess().getZINTTerminalRuleCall_3_0(), semanticObject.getZ());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Point returns Point2D
	 *
	 * Constraint:
	 *     (i=INT j=INT map=Map)
	 */
	protected void sequence_Point_Point2D(ISerializationContext context, Point2D semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DumePackage.Literals.POINT2_D__I) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DumePackage.Literals.POINT2_D__I));
			if (transientValues.isValueTransient(semanticObject, DumePackage.Literals.POINT2_D__J) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DumePackage.Literals.POINT2_D__J));
			if (transientValues.isValueTransient(semanticObject, DumePackage.Literals.POINT2_D__MAP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DumePackage.Literals.POINT2_D__MAP));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPoint2DAccess().getIINTTerminalRuleCall_1_0(), semanticObject.getI());
		feeder.accept(grammarAccess.getPoint2DAccess().getJINTTerminalRuleCall_2_0(), semanticObject.getJ());
		feeder.accept(grammarAccess.getPointAccess().getMapMapParserRuleCall_1_2_0(), semanticObject.getMap());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Script returns Script
	 *
	 * Constraint:
	 *     (name=ID instructions+=Instruction*)
	 */
	protected void sequence_Script(ISerializationContext context, Script semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Scripts returns Scripts
	 *
	 * Constraint:
	 *     script+=Script+
	 */
	protected void sequence_Scripts(ISerializationContext context, Scripts semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Shape returns Shape2D
	 *     Shape2D returns Shape2D
	 *
	 * Constraint:
	 *     (map=Map points+=Point2D*)
	 */
	protected void sequence_Shape2D(ISerializationContext context, Shape2D semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Shape returns Shape3D
	 *     Shape3D returns Shape3D
	 *
	 * Constraint:
	 *     points+=Point3D*
	 */
	protected void sequence_Shape3D(ISerializationContext context, Shape3D semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
