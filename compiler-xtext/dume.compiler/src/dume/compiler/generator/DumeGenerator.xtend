/*
 * generated by Xtext 2.17.0
 */
package dume.compiler.generator

import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import dume.compiler.dume.Script
import dume.compiler.dume.Instruction
import dume.compiler.dume.Drawing
import dume.compiler.dume.Go
import dume.compiler.dume.Point
import dume.compiler.dume.Shape
import dume.compiler.dume.Point2D
import dume.compiler.dume.Point3D
import dume.compiler.dume.Shape2D
import dume.compiler.dume.Shape3D
import dume.compiler.dume.Loop
import dume.compiler.dume.Circle
import dume.compiler.dume.Number
import dume.compiler.dume.Positive
import dume.compiler.dume.Negative

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class DumeGenerator extends AbstractGenerator {

	static final int CIRCLE_POINT_NUMBER = 10;
	static double mapDistance = 30;
	static final double SCALE = 100;

	boolean firstPoint;

	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {

		firstPoint = false;

		for (e : resource.allContents.toIterable.filter(Script)) {
			fsa.generateFile(e.name + ".sbot", e.compile)
		}
	}

	def compile(Shape2D shape) '''
		«FOR point : shape.points»
			«goPoint2D(point.i.getValue(),point.j.getValue(), shape.map)»
		«ENDFOR»
	'''

	def int getValue(Number number) {

		var value = number.v

		switch number {
			Negative: value *= -1
		}

		return value
	}

	def compile(Shape3D shape) '''
		«FOR point : shape.points»
			«point.compile»
		«ENDFOR»
	'''

	def compile(Shape shape) {

		firstPoint = true

		return switch shape {
			Shape2D: (shape as Shape2D).compile
			Shape3D: (shape as Shape3D).compile
			Circle: (shape as Circle).compile
			default: '''error'''
		}
	}

	def compile(Circle circle) {

		var map = circle.map

		var radius = circle.radius

		var ci = circle.point.i.getValue()
		var cj = circle.point.j.getValue()

		var step = Math.PI * 2.0 / CIRCLE_POINT_NUMBER

		return '''
			«FOR i : 0..CIRCLE_POINT_NUMBER»
				«goPoint2D(Math.cos(step*i)*radius + ci, Math.sin(step*i)*radius + cj, map)»
			«ENDFOR»
		'''
	}

	def goPoint2D(double i, double j, String map) {

		var x = 0.0
		var y = 0.0
		var z = 0.0

		if (map == "A") {
			x = i
			y = j + mapDistance
			z = mapDistance
		} else if (map == "") {
		} else if (map == "") {
		}

		return goPoint3D(x, y, z);
	}

	def goPoint3D(double x, double y, double z) {

		var cmd = "go"
		if (firstPoint) {
			cmd = "reach"
			firstPoint = false
		}

		return '''
			«cmd» «x/dume.compiler.generator.DumeGenerator.SCALE» «y/dume.compiler.generator.DumeGenerator.SCALE» «z/dume.compiler.generator.DumeGenerator.SCALE»
		'''
	}

	def compile(Point3D point) {
		return goPoint3D(point.x.getValue(), point.y.getValue(), point.z.getValue())
	}

	def compile(Point point) {
		return switch point {
			Point2D:
				goPoint2D((point as Point2D).i.getValue(), (point as Point2D).j.getValue(), point.map)
			Point3D:
				(point as Point3D).compile
			default: '''error'''
		}
	}

	def compile(Go go) '''
		go «go.point.compile»
	'''

	def compile(Drawing drawing) '''
		clear organ
		«FOR shape : drawing.shapes»
			organ on
			«shape.compile»
			organ off
		«ENDFOR»
	'''

	def compile(Instruction instruction) {
		return switch instruction {
			Drawing:
				(instruction as Drawing).compile
			Go:
				(instruction as Go).compile
			Loop:
				(instruction as Loop).compile
			default: '''
				error
			'''
		}
	}

	def compile(Loop loop) '''
		«FOR i : 0..loop.n»
			«FOR instruction : loop.instructions»
				«instruction.compile»
			«ENDFOR»
		«ENDFOR»
	'''

	def compile(Script robotScript) '''
		«FOR instruction : robotScript.instructions»
			«instruction.compile»
		«ENDFOR»
	'''
}
